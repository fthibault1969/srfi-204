Test suite: gerbil-match-test
Test case: test: any
gerbil-v0.16-109-g58c5eef2
... check (match 'any (_ 'ok)) is equal? to ok
... 1 checks OK
Test case: test: symbol
... check (match 'ok (x x)) is equal? to ok
... 1 checks OK
Test case: test: number
... check (match 28 (28 'ok)) is equal? to ok
... 1 checks OK
Test case: test: string
... check (match good (bad 'fail) (good 'ok)) is equal? to ok
... 1 checks OK
Test case: test: literal symbol
... check (match 'good ('bad 'fail) ('good 'ok)) is equal? to ok
... 1 checks OK
Test case: test: null
... check (match '() (() 'ok)) is equal? to ok
... 1 checks OK
Test case: test: pair
... check (match '(ok) ((x) x)) is equal? to ok
... 1 checks OK
Test case: test: vector
... check (match '#(ok) (#(x) x)) is equal? to ok
... 1 checks OK
Test case: test: any doubled
... check (match '(1 2) ((_ _) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: and empty
... check (match '(o k) ((and) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: and single
... check (match 'ok ((and x) x)) is equal? to ok
... 1 checks OK
Test case: test: and double
... check (match 'ok ((and (? symbol?) y) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: or empty
... check (match '(o k) ((or) 'fail) (else 'ok)) is equal? to ok
... 1 checks OK
Test case: test: or single
... check (match 'ok ((or x) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: or double
... check (match 'ok ((or (? symbol? y) y) y)) is equal? to ok
... 1 checks OK
Test case: test: not
... check (match 28 ((not (a . b)) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: pred
... check (match 28 ((? number?) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: named pred
... check (match 28 ((? number? x) (+ x 1))) is equal? to 29
... 1 checks OK
Test case: test: duplicate symbols pass
... check (match '(ok . ok) ((x . x) x)) is equal? to ok
... 1 checks OK
Test case: test: duplicate symbols fail
... check (match '(ok . bad) ((x . x) 'bad) (else 'ok)) is equal? to ok
... 1 checks OK
Test case: test: duplicate symbols samth
... check (match '(ok . ok) ((x quote bad) x) (('ok . x) x)) is equal? to ok
... 1 checks OK
Test case: test: duplicate symbols bound
... check (let ((a '(1 2))) (match a ((and (a 2) (1 b)) (+ a b)) (_ #f))) is equal? to 3
... 1 checks OK
Test case: test: duplicate quasiquote
... check (match '(a b) ((or `(a ,x) `(,x b)) 'ok) (_ #f)) is equal? to ok
... 1 checks OK
Test case: test: ellipses
... check (match '((a . 1) (b . 2) (c . 3)) (((x . y) ___) (list x y))) is equal? to ((a b c) (1 2 3))
... 1 checks OK
Test case: test: real ellipses
... check (match '((a . 1) (b . 2) (c . 3)) (((x . y) ...) (list x y))) is equal? to ((a b c) (1 2 3))
... 1 checks OK
Test case: test: vector ellipses
... check (match '#(1 2 3 (a . 1) (b . 2) (c . 3)) (#(a b c (hd . tl) ...) (list a b c hd tl))) is equal? to (1 2 3 (a b c) (1 2 3))
... 1 checks OK
Test case: test: pred ellipses
... check (match '(1 2 3) (((? odd? n) ___) n) (((? number? n) ___) n)) is equal? to (1 2 3)
... 1 checks OK
Test case: test: failure continuation
... check (match '(1 2) ((a . b) (=> next) (if (even? a) 'fail (next))) ((a . b) 'ok)) is equal? to ok
... 1 checks OK
Test case: test: let
... check (match-let ((x 'ok) (y '(o k))) y) is equal? to (o k)
... 1 checks OK
Test case: test: let*
... check (match-let* ((x 'f) (y 'o) ((z w) (list y x))) (list x y z w)) is equal? to (f o o f)
... 1 checks OK
Test case: test: getter car
... check (match '(1 . 2) (((get! a) . b) (list (a) b))) is equal? to (1 2)
... 1 checks OK
Test case: test: getter cdr
... check (match '(1 . 2) ((a get! b) (list a (b)))) is equal? to (1 2)
... 1 checks OK
Test case: test: getter vector
... check (match '#(1 2 3) (#((get! a) b c) (list (a) b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: setter car
... check (let ((x (cons 1 2))) (match x (((set! a) . b) (a 3))) x) is equal? to (3 . 2)
... 1 checks OK
Test case: test: setter cdr
... check (let ((x (cons 1 2))) (match x ((a set! b) (b 3))) x) is equal? to (1 . 3)
... 1 checks OK
Test case: test: setter vector
... check (let ((x (vector 1 2 3))) (match x (#(a (set! b) c) (b 0))) x) is equal? to #(1 0 3)
... 1 checks OK
Test case: test: single tail
... check (match '((a . 1) (b . 2) (c . 3)) (((x . y) ... last) (list x y last))) is equal? to ((a b) (1 2) (c . 3))
... 1 checks OK
Test case: test: single tail 2
... check (match '((a . 1) (b . 2) 3) (((x . y) ... last) (list x y last))) is equal? to ((a b) (1 2) 3)
... 1 checks OK
Test case: test: single duplicate tail
... check (match '(1 2) ((foo ... foo) foo) (_ #f)) is equal? to #f
... 1 checks OK
Test case: test: multiple tail
... check (match '((a . 1) (b . 2) (c . 3) (d . 4) (e . 5)) (((x . y) ... u v w) (list x y u v w))) is equal? to ((a b) (1 2) (c . 3) (d . 4) (e . 5))
... 1 checks OK
Test case: test: tail against improper list
... check (match '(a b c d e f . g) ((x ... y u v w) (list x y u v w)) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: Riastradh quasiquote
... check (match '(1 2 3) (`(1 ,b ,c) (list b c))) is equal? to (2 3)
... 1 checks OK
Test case: test: unquote-splicing
... check (match '(1 2 3) (`(1 ,@ls) ls)) is equal? to (2 3)
... 1 checks OK
Test case: test: unquote-splicing tail
... check (match '(a b c d) (`(a ,@ls d) ls)) is equal? to (b c)
... 1 checks OK
Test case: test: unquote-splicing tail fail
... check (match '(a b c e) (`(a ,@ls d) ls) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: trivial tree search
... check (match '(1 2 3) ((_ *** (a b c)) (list a b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: simple tree search
... check (match '(x (1 2 3)) ((_ *** (a b c)) (list a b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: deep tree search
... check (match '(x (x (x (1 2 3)))) ((_ *** (a b c)) (list a b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: non-tail tree search
... check (match '(x (x (x a b c (1 2 3) d e f))) ((_ *** (a b c)) (list a b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: restricted tree search
... check (match '(x (x (x a b c (1 2 3) d e f))) (('x *** (a b c)) (list a b c))) is equal? to (1 2 3)
... 1 checks OK
Test case: test: fail restricted tree search
... check (match '(x (y (x a b c (1 2 3) d e f))) (('x *** (a b c)) (list a b c)) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: sxml tree search
... check (match '(p (ul (li a (b c) (a (@ (href . http://synthcode.com/)) synthcode) d e f))) (((or 'p 'ul 'li 'b) *** ('a ('@ attrs ...) text ...)) (list attrs text)) (else #f)) is equal? to (((href . "http://synthcode.com/")) ("synthcode"))
... 1 checks OK
Test case: test: failed sxml tree search
... check (match '(p (ol (li a (b c) (a (@ (href . http://synthcode.com/)) synthcode) d e f))) (((or 'p 'ul 'li 'b) *** ('a ('@ attrs ...) text ...)) (list attrs text)) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: collect tree search
... check (match '(p (ul (li a (b c) (a (@ (href . http://synthcode.com/)) synthcode) d e f))) (((and tag (or 'p 'ul 'li 'b)) *** ('a ('@ attrs ...) text ...)) (list tag attrs text)) (else #f)) is equal? to ((p ul li) ((href . "http://synthcode.com/")) ("synthcode"))
... 1 checks OK
Test case: test: anded tail pattern
... check (match '(1 2 3) ((and (a ... b) x) a)) is equal? to (1 2)
... 1 checks OK
Test case: test: anded search pattern
... check (match '(a (b (c d))) ((and (p *** 'd) x) p)) is equal? to (a b c)
... 1 checks OK
Test case: test: joined tail
... check (match '(1 2 3) ((and (a ... b) x) a)) is equal? to (1 2)
... 1 checks OK
Test case: test: list **1
... check (match '(a b c) ((x **1) x)) is equal? to (a b c)
... 1 checks OK
Test case: test: list **1 failed
... check (match '() ((x **1) x) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list **1 with predicate
... check (match '(a b c) (((and x (? symbol?)) **1) x)) is equal? to (a b c)
... 1 checks OK
Test case: test: list **1 with failed predicate
... check (match '(a b 3) (((and x (? symbol?)) **1) x) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list =.. too few
... check (match (list 1 2) ((a b =.. 2) b) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list =..
... check (match (list 1 2 3) ((a b =.. 2) b) (else #f)) is equal? to (2 3)
... 1 checks OK
Test case: test: list =.. too many
... check (match (list 1 2 3 4) ((a b =.. 2) b) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list =.. tail
... check (match (list 1 2 3 4) ((a b =.. 2 c) c) (else #f)) is equal? to 4
... 1 checks OK
Test case: test: list =.. tail fail
... check (match (list 1 2 3 4 5 6) ((a b =.. 2 c) c) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list *.. too few
... check (match (list 1 2) ((a b *.. 2 4) b) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list *.. lo
... check (match (list 1 2 3) ((a b *.. 2 4) b) (else #f)) is equal? to (2 3)
... 1 checks OK
Test case: test: list *.. hi
... check (match (list 1 2 3 4 5) ((a b *.. 2 4) b) (else #f)) is equal? to (2 3 4 5)
... 1 checks OK
Test case: test: list *.. too many
... check (match (list 1 2 3 4 5 6) ((a b *.. 2 4) b) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: list *.. tail
... check (match (list 1 2 3 4) ((a b *.. 2 4 c) c) (else #f)) is equal? to 4
... 1 checks OK
Test case: test: list *.. tail 2
... check (match (list 1 2 3 4 5) ((a b *.. 2 4 c d) d) (else #f)) is equal? to 5
... 1 checks OK
Test case: test: list *.. tail
... check (match (list 1 2 3 4 5 6) ((a b *.. 2 4 c) c) (else #f)) is equal? to 6
... 1 checks OK
Test case: test: list *.. tail fail
... check (match (list 1 2 3 4 5 6 7) ((a b *.. 2 4 c) c) (else #f)) is equal? to #f
... 1 checks OK
Test case: test: match-named-let
... check (match-let loop (((x . rest) '(1 2 3)) (sum 0)) (let ((sum (+ x sum))) (if (null? rest) sum (loop rest sum)))) is equal? to 6
... 1 checks OK
Test case: match-letrec
... check (match-letrec (((x y) (list 1 (lambda () (list a x)))) ((a b) (list 2 (lambda () (list x a))))) (append (y) (b))) is equal? to (2 1 1 2)
*** FAILED: (check equal? (match-letrec (((x y) (list 1 (lambda () (list a x)))) ((a b) (list 2 (lambda () (list x a))))) (append (y) (b))) '(2 1 1 2)) at "test.ss"@309.14; value: (#<procedure #12 #:b152918> #<procedure #12 #:b152918> #<procedure #12 #:b152918> #<procedure #12 #:b152918>)
Test case: test: match-letrec quote
... check (match-letrec (((x 'x) (list #t 'x))) x) is equal? to #t
... 1 checks OK
*** Test FAILED
--- Test Summary
gerbil-match-test: FAILED
match-letrec: Check FAILED (check equal? (match-letrec (((x y) (list 1 (lambda () (list a x)))) ((a b) (list 2 (lambda () (list x a))))) (append (y) (b))) '(2 1 1 2)) at "test.ss"@309.14
FAILURE
